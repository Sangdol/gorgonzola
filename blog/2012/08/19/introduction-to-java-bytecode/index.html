<!DOCTYPE html>
<html lang="ko-kr">
<head>
    <title>이상현 IN 베를린 :: 자바 바이트코드 소개</title>
        <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="index,follow">
    <meta name="description" content="베를린 사는 소프트웨어 엔지니어 이야기">
    <meta name="twitter:title" content="자바 바이트코드 소개" />
    <meta name="twitter:description" content="베를린 사는 소프트웨어 엔지니어 이야기" />
    <meta name="twitter:creator" content="@sangdolha" />
    <meta name="twitter:card" content="summary_large_image">

    
    <meta name="twitter:image" content="https://iamsang.com/logo.png" />

    
    <meta property="og:image" content="https://iamsang.com/logo.png" />


    <link rel="shortcut icon" type="image/png" href="/icon-192x192.png">
    <link rel="shortcut icon" sizes="192x192" href="/icon-192x192.png">
    <link rel="apple-touch-icon" href="/icon-192x192.png">

    <link rel="manifest" href="/site.webmanifest">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      document.querySelectorAll('pre code').forEach((block) => {
        hljs.highlightBlock(block);
      });
    });
    </script>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Ubuntu+Mono:400,400i,700,700i|Raleway:500">
    <link href="/css/normalize.css" rel="stylesheet">
    <link rel="stylesheet" href="/css/sakura.css">
    <link href="/css/custom.css" rel="stylesheet">
    <script>(function(a,s,y,n,c,h,i,d,e){s.className+=' '+y;h.start=1*new Date;
            h.end=i=function(){s.className=s.className.replace(RegExp(' ?'+y),'')};
            (a[n]=a[n]||[]).hide=h;setTimeout(function(){i();h.end=null},c);h.timeout=c;
            })(window,document.documentElement,'async-hide','dataLayer',4000,
            {'GTM-PGRQWF8':true});
    </script>
    <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
          ga('create', 'UA-23501808-2', 'auto');
          ga('require', 'GTM-PGRQWF8');
          ga('send', 'pageview');

    </script>
    <script>
    /**
    * Function that captures a click on an outbound link in Analytics.
    * This function takes a valid URL string as an argument, and uses that URL string
    * as the event label. Setting the transport method to 'beacon' lets the hit be sent
    * using 'navigator.sendBeacon' in browser that support it.
    */
    var captureOutboundLink = function(url) {
       ga('send', 'event', 'outbound', 'click', url, {
         'transport': 'beacon'
       });
    }
    </script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script>
    // capturing outbound link
    $(function () {
      $('a[href^="https:"]:not(a[href^="https://' + document.location.hostname + '"])').click(function () {
        captureOutboundLink($(this).attr('href'));
      });
    });

    // new window for outbound link
    $(function () {
      $('a[href^="https:"]:not(a[href^="https://' + document.location.hostname + '"])').attr('target', '_blank');
    });

    console.log("안녕하세요, 이상현입니다. 제 블로그에 있는 html, css, js 등은 그냥 가져다 쓰셔도 됩니다. 좋은 하루 되세요.")
    </script>
</head>
<body>
    <section class="top">
        <nav>
            <a href="/"><span>글</span></a>
            <a href="/about"><span>소개</span></a>
            <a href="/popular"><span>인기글</span></a>
            <a href="/subscribe"><span>구독</span></a>
            <a href="https://twitter.com/sangdolha"><span>트위터</span></a>
        </nav>
    </section>
    <hr class="top-line">
    <section class="header">
        <div class="container">
            <div class="content">
                <a href="/">
                    <div class="name">
                        이상현
                        <span class="colored" style="font-weight:100">in</span>
                        <span style="font-weight:300">베를린</span>
                    </div>
                </a>
            </div>
        </div>
    </section>
<div class="container article">
    <div class="page-heading">자바 바이트코드 소개</div>
    <blockquote><p> Understanding bytecode and what bytecode is likely to be generated by a Java compiler helps the Java programmer in the same way that knowledge of assembly helps the C or C++ programmer. - IBM developerWorks journal </p></blockquote><p>개발을 하다 보면 때로는 로우 레벨에 대한 이해가 필요할 때가 있습니다. 하지만 이클립스나 인텔리J와 같은 IDE를 이용해 개발하는 개발자들에게는 javac나 javap와 같은 간단한 자바 명령어조차 낯선 것이 사실입니다.</p><p>이 글에서는 자바 바이트코드(Bytecode)에 대해 살펴보며 자바 프로그램이 어떤 식으로 컴파일되고 실행되는지에 대해 설명하겠습니다.</p><h3>컴파일러</h3><p>자바 바이트코드는 JVM(Java virtual machine)이 실행하는 명령어 집합입니다. 컴파일하면 생성되는 <a href='http://en.wikipedia.org/wiki/Java_class_file'>.class 파일</a>이 바이트코드를 담고 있습니다.</p><p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/Java_virtual_machine_architecture.svg/400px-Java_virtual_machine_architecture.svg.png" alt="JVM 아키텍처의 개요(출처: 위키피디아)" /></p><p>위 그림과 같이 컴파일을 통해 생성된 바이트코드 파일들은 OS나 개발환경에 관계없이 같은 명령어 집합을 사용하며, 이것이 자바의 크로스 플랫폼 동작을 가능하게 해주는 부분입니다.</p><p>위 JVM 아키텍처를 자세히 보면 (우측의 Python 관련 그림을 제외하고 보더라도) 두 종류의 컴파일러가 있다는 것을 알 수 있습니다. 첫 번째 컴파일러는 <a href='http://en.wikipedia.org/wiki/Java_compiler'>자바 코드를 자바 클래스 파일로 만들어주는 컴파일러</a>입니다. 위 그림에서는 <a href='http://en.wikipedia.org/wiki/Javac'>javac</a>로 표기된 부분으로 <a href='http://en.wikipedia.org/wiki/Java_Development_Kit'>JDK(Java Development Kit)</a>에 포함된 기본 컴파일러입니다. 일반적으로 자바 컴파일러를 말할 때에는 바이트코드를 생성하는 이 컴파일러를 말합니다. 이후에 JRE(Java Runtime Environment)에서 더 나은 최적화를 하기 위해서 이 단계에서는 <a href='http://en.wikipedia.org/wiki/Loop_unwinding'>loop unrolling</a>, algebraic simplification, <a href='http://en.wikipedia.org/wiki/Strength_reduction'>strength reduction</a>와 같은 기본적인 최적화도 하지 않습니다.</p><p>참고로 이클립스는 독자적인 컴파일러를 사용합니다. 따라서 JDK를 설치하지 않고도 이클립스에서 컴파일이 가능합니다. 이클립스의 컴파일러는 다음과 같은 기능을 제공합니다.</p><ul><li>프로젝트에서 수정된 부분만 컴파일하는 증분컴파일(Incremental compilation) 기능</li><li>일부 코드에 에러가 있더라도 클래스 파일을 생성하는 기능(모든 파일이 정상 컴파일되지 않더라도 프로젝트가 동작할 수 있도록 하기 위함)</li><li><a href='http://en.wikipedia.org/wiki/Abstract_syntax_tree'>AST</a> 생성(Outline 보기, 리팩토링과 같은 기능을 가능하게 함)</li></ul><p>위 아키텍처에서 다음으로 볼 수 있는 컴파일러는 <a href='http://en.wikipedia.org/wiki/Just-in-time_compilation'>JIT(Just In Time) 컴파일러</a>입니다. JVM은 동적으로 바이트코드를 읽으며 인터프리팅을 하는데, 이 단계에서 JIT 컴파일러는 자바 애플리케이션의 성능향상을 위해 <a href='http://en.wikipedia.org/wiki/Dynamic_compilation'>동적 컴파일</a>을 통해 머신코드(Machine code)로 컴파일 가능한 코드들을 한 번 더 컴파일합니다. 이처럼 미리 컴파일하지 않고 실행 중 동적으로 컴파일하는데, 컴파일러의 이름이 Just In Time인 이유가 바로 여기에 있습니다.</p><h3>바이트코드는 공부할 가치가 있을까?</h3><p>바이트코드 학습을 통해 얻을 수 있는 것에는 어떤 것들이 있을까요? 바이트코드를 분석할 수 있게 되어 좀 더 성능이 좋은 코드를 작성할 수 있을까요? 별로 그렇지 않습니다. 앞서 이야기했듯이 성능 최적화는 JIT 컴파일러 단계에서 진행되며 이것은 JVM마다 다르게 구현되어 있어 사실상 바이트코드만으로는 해당 코드가 어떻게 머신코드로 변경되고 최적화될지 알 수 없습니다. 바이트코드 수준의 최적화란 거의 의미가 없다고 볼 수 있으며, 그것보다 중요한 것은 사람이 보기 좋은 코드를 작성하는 것입니다.</p><p>그렇다면 바이트코드는 왜 배워야 할까요. <a href='http://programmers.stackexchange.com/questions/156722/how-does-learning-assembly-aid-in-programming'>어셈블리어를 왜 배워야하냐</a>는 질문에 대한 답변으로 나온 아래 문장이 바이트코드를 배워야 하는 이유를 잘 설명해줍니다.</p><blockquote><p> Because you'll understand how it really works. </p></blockquote><p>조금 더 덧붙이자면 바이트코드에 대한 이해는 더 훌륭한 자바 개발자가 되도록 도와줄 것이라는 점입니다.</p><h3>바이트코드 명령어(opcode)</h3><p>한 바이트에는 256개의 값이 있듯이 바이트코드에는 256개가량의 <a href='http://en.wikipedia.org/wiki/Opcode'>opcode</a>들이 존재합니다. 각각의 명령어들은 넓게 다음과 같이 분류할 수 있습니다.</p><ul><li>읽고 쓰기 (e.g. aload_0, istore)</li><li>산술논리 연산 (e.g. ladd, fcmpl)</li><li>타입변환 (e.g. i2b, d2i)</li><li>객체생성 및 조작 (new, putfield)</li><li>오퍼랜드 스택 관리 (e.g. swap, dup2)</li><li>제어 (e.g. ifeq, goto)</li><li>함수 호출 및 반환 (e.g. invokespecial, areturn)</li></ul><p>많은 명령어는 피연산자(operand)의 타입을 나타내는 접두사(prefix) 또는 접미사(suffix)를 가지고 있습니다. 아래는 각 접두사/접미사가 나타내는 피연산자 타입입니다.</p><p><table><tbody><tr><th>접두사/접미사</th>             <th>피연산자 타입</th>         </tr><tr><td><code>i</code></td>             <td>integer</td>         </tr><tr><td><code>l</code></td>             <td>long</td>         </tr><tr><td><code>s</code></td>             <td>short</td>         </tr><tr><td><code>b</code></td>             <td>byte</td>         </tr><tr><td><code>c</code></td>             <td>character</td>         </tr><tr><td><code>f</code></td>             <td>float</td>         </tr><tr><td><code>d</code></td>             <td>double</td>         </tr><tr><td><code>a</code></td>             <td>reference</td>         </tr></tbody></table></p><p>모든 명령어의 리스트는 위키피디아의 <a href='http://en.wikipedia.org/wiki/Java_bytecode_instruction_listings'>Java bytecode instruction listings</a> 페이지에서 찾아볼 수 있습니다.</p><h3>바이트코드 시작하기</h3><p>코드를 컴파일하여 바이트코드를 직접 살펴보겠습니다. 바이트코드는 다음과 같은 형식을 가집니다.</p><p><code>&lt;index&gt;&lt;opcode&gt; &#91;&lt;operand1&gt; &#91;&lt;operand2&gt;...&#93;&#93; &#91;&lt;comment&gt;&#93;</code></p><p>형식만 봐서는 와닿지 않으니 예제를 통해 살펴보겠습니다.</p><p><script src="https://gist.github.com/3370455.js?file=Person.java"></script></p><p>위와 같은 클래스를 컴파일해보겠습니다.</p><pre><code>javac Person.java</code></pre><p>컴파일되어 나온 <code>Person.class</code> 파일을 통해 바이트코드를 확인해보겠습니다.</p><pre><code>javap -c Person</code></pre><p>위와 같이 기본 자바 클래스 파일 Disassembler 프로그램인 <a href='http://docs.oracle.com/javase/1.5.0/docs/tooldocs/windows/javap.html'>javap</a>를 실행시키면 다음과 같은 코드가 나타납니다.</p><p><pre><code> Compiled from "Person.java" public class Person extends java.lang.Object{ int age;</p><p>public Person();   Code:    0: aload_0    1: invokespecial #1; //Method java/lang/Object."<init>":()V    4: aload_0    5: bipush  10    7: putfield  #2; //Field age:I    10:  return</p><p>public int getAge();   Code:    0: aload_0    1: getfield  #2; //Field age:I    4: ireturn</p><p>public void setAge(int);   Code:    0: aload_0    1: iload_1    2: putfield  #2; //Field age:I    5: return</p><p>} </init></code></pre></p><p>위 바이트코드 중 일부를 살펴보겠습니다.</p><pre><code>5:  bipush  10</code></pre><p>위 코드는 인덱스 5에서 <code>bipush</code>라는 opcode가 <code>10</code>이라는 피연산자를 가지고 있습니다. 한 줄 더 살펴보겠습니다.</p><pre><code>7:  putfield  #2; //Field age:I</code></pre><p>위 코드는 해시(#)가 달린 피연산자를 가지고 있습니다. 이것은 상수풀(constant pool)에서의 인덱스를 나타냅니다. 그리고 해당 피연산자가 가리키는 아이템을 나타내는 주석이 뒤따라 옵니다. 해당 주석은 javap가 생성한 주석입니다.</p><p>이제 다시 바이트코드의 형식을 보면 이해가 잘 될 것입니다.</p><p><code>&lt;index&gt;&lt;opcode&gt; &#91;&lt;operand1&gt; &#91;&lt;operand2&gt;...&#93;&#93; &#91;&lt;comment&gt;&#93;</code></p><p>이번에는 Person 클래스의 바이트코드를 부분별로 나누어 분석해보겠습니다.</p><p><pre><code> public Person();   Code:    0: aload_0    1: invokespecial #1; //Method java/lang/Object."<init>":()V    4: aload_0    5: bipush  10    7: putfield  #2; //Field age:I    10:  return </init></code></pre></p><p>위 코드는 Person 클래스의 생성자를 나타내는 부분입니다. 코드에는 생성자가 없지만, 컴파일러가 기본 생성자를 만들어냈습니다.</p><p>생성자의 첫 줄에서는 <code>aload&#95;0</code> 명령어를 통해 지역변수배열(Array of local variables)의 0번째에 있는 값을 피연산자 스택(Operand Stack)으로 로드합니다.</p><p>이것이 대체 무슨 말인지 이해하기 위해 잠시 JVM이 바이트코드를 어떤 방식으로 실행하는지에 대해 살펴볼 필요가 있습니다. JVM은 스택기반머신입니다. 각 스레드는 JVM 스택을 가지고 이 스택에는 <a href='http://docs.oracle.com/javase/specs/jvms/se5.0/html/Overview.doc.html#17257'>프레임(frame)</a>들이 저장됩니다. 프레임은 생성자 또는 함수가 실행될 때 생성되는 것으로 아래 그림과 같이 지역변수배열과 피연산자 스택 그리고 상수풀에 대한 참조로 구성되어 있습니다.</p><p><img src="http://www.ibm.com/developerworks/ibm/library/it-haggar_bytecode/fig01.gif" alt="프레임(출처: IBM 저널)" /></p><p>그림의 상단에서 볼 수 있는 지역변수배열에는 객체에 대한 참조(<code>this</code>), 메소드의 인자 그리고 지역변수들이 0번 위치부터 차례대로 들어갑니다. static 함수의 경우에는 파라미터가 0번 위치부터 들어갑니다(static 함수에서는 <code>this</code>를 쓸 수 없습니다).</p><p>이클립스를 통해 자바 프로그램을 디버깅해본 경험이 있다면 프레임을 알든 모르든 누구나 프레임을 본 적이 있을 것입니다.</p><p><img src="http://media.tumblr.com/tumblr_m901glDZbG1qimauz.png" alt="이클립스 디버그 뷰에서 볼 수 있는 프레임" title="이클립스 디버그 뷰에서 볼 수 있는 프레임" /></p><p>자, 이제 다시 Person 클래스의 바이트코드로 돌아가 보겠습니다(코드가 너무 멀어졌으니 다시 복사해서 보겠습니다).</p><p><pre><code> public Person();   Code:    0: aload_0    1: invokespecial #1; //Method java/lang/Object."<init>":()V    4: aload_0    5: bipush  10    7: putfield  #2; //Field age:I    10:  return </init></code></pre></p><p>이제 <code>aload&#95;0</code>이 무엇을 하는지 알 수 있게 되었습니다. 지역변수배열의 0번째 위치에 있던 <code>this</code>를 피연산자 스택에 넣는 동작을 합니다. 앞서 이야기했듯이 <code>aload&#95;0</code>에서 <code>a</code>는 피연산자의 타입을 나타내는 접두사로 참조를 로드한다는 것을 나타냅니다.</p><p>다음 라인의 <code>invokespecial</code> 명령어는 상위 클래스(Superclass)의 생성자를 호출합니다. 자바에서 명시적으로 상속을 받지 않는 클래스는 암시적으로 Object를 상속받기 때문에 컴파일러가 이러한 코드를 생성한 것입니다. 이 단계에서 피연산자 스택의 가장 상위에 있던 <code>this</code>가 빠져나오게 됩니다.</p><p>다음 인덱스 4~7의 코드들은 <code>age</code> 필드에 <code>10</code>을 할당하는 부분입니다. <code>aload&#95;0</code>을 통해 <code>this</code>를 로드(피연산자 스택에 push)하고 <code>bipush 10</code>을 통해 <code>10</code>을 다시 스택에 넣습니다. 그리고 <code>putfield</code> 명령어에서는 이 두 값과 필드 참조 값 <code>#2</code>를 이용하여 <code>age</code> 필드에 값을 할당합니다.</p><p>마지막으로 <code>return</code> 명령어를 통해 반환 값 없이 함수를 종료합니다. 함수가 반환 값을 가질 때에는 <code>areturn</code> 또는 <code>ireturn</code>과 같이 타입 접두사가 붙은 명령어를 실행합니다.</p><p>이제 나머지 코드를 살펴보겠습니다.</p><p><pre><code> public int getAge();   Code:    0: aload_0    1: getfield  #2; //Field age:I    4: ireturn</p><p>public void setAge(int);   Code:    0: aload_0    1: iload_1    2: putfield  #2; //Field age:I    5: return </code></pre></p><p>생성자를 보고나니 getter/setter는 쉬워 보입니다.</p><p><code>getAge</code> 메소드에서는 참조를 로드한 후 <code>getfield</code> 명령어에서 참조를 이용하여 <code>age</code>의 값을 다시 스택에 넣습니다. 그리고 <code>ireturn</code> 명령어를 통해 스택의 값을 반환합니다.</p><p><code>setAge</code> 메소드의 명령어들은 생성자에서 사용된 명령어와 같아 다시 볼 필요가 없어보입니다.</p><h3>if 문과 switch 문 비교</h3><p>얼마 전 직장동료와 "if 문과 switch 문에 성능차이가 있을까?"라는 것에 관해 이야기 나눈 적이 있습니다. <a href='http://stackoverflow.com/questions/2086529/what-is-the-relative-performance-difference-of-if-else-versus-switch-statement-i'>if 문과 switch 문의 성능차이를 이용하여 최적화를 하려고 하는 것은 분명 어리석은 생각</a>이지만 내부적으로 if 문과 switch 문이 어떻게 동작하는지에 대해 알아보는 것은 의미가 있습니다.</p><p>같은 동작을 하는 if 문과 switch 문 함수를 준비하였습니다. 각 함수는 static으로 선언하였습니다.</p><p><script src="https://gist.github.com/3388251.js?file=IfAndSwitch.java"></script></p><p>위 클래스의 바이트코드를 확인해보겠습니다.</p><p><pre><code> public static void ifFunc(int);   Code:    0: iload_0    1: iconst_1    2: if_icmpne 15    5: getstatic #2; //Field java/lang/System.out:Ljava/io/PrintStream;    8: iconst_1    9: invokevirtual #3; //Method java/io/PrintStream.println:(I)V    12:  goto  27    15:  iload_0    16:  iconst_2    17:  if_icmpne 27    20:  getstatic #2; //Field java/lang/System.out:Ljava/io/PrintStream;    23:  iconst_2    24:  invokevirtual #3; //Method java/io/PrintStream.println:(I)V    27:  return</p><p>public static void switchFunc(int);   Code:    0: iload_0    1: lookupswitch{ //2     1: 28;     2: 38;     default: 45 }    28:  getstatic #2; //Field java/lang/System.out:Ljava/io/PrintStream;    31:  iconst_1    32:  invokevirtual #3; //Method java/io/PrintStream.println:(I)V    35:  goto  45    38:  getstatic #2; //Field java/lang/System.out:Ljava/io/PrintStream;    41:  iconst_2    42:  invokevirtual #3; //Method java/io/PrintStream.println:(I)V    45:  return </code></pre></p><p>switch 문의 코드가 조금 더 간결해 보입니다. 바이트코드를 살펴보면 if 문은 <code>if&#95;icmpne</code> 명령어를 통해 한 단계씩 비교하며 이동하는 반면 switch 문은 <code>lookupswitch</code>라는 명령어를 통해 한 번에 목표지점으로 이동하는 것을 알 수 있습니다. switch문이 조금 더 효율적으로 동작할 것이라 예상할 수 있습니다.</p><p>바이트코드를 좀 더 자세히 살펴보면 if 문의 인덱스 0에서 <code>iload&#95;0</code>을 통해 로컬변수 배열의 0번째 값을 로드하고 있습니다. 인스턴스 메소드일 경우 0번째 값은 객체참조이지만 여기서 사용된 것은 static 메소드이므로 0번째 값은 첫 번째 인자가 됩니다.</p><p>다음 줄에서는 <code>iconst&#95;1</code> 명령어를 통해 int 값 <code>1</code>을 스택에 넣습니다. 기억력이 좋은 분이라면 앞서 Person 클래스에서는 <code>10</code>이라는 값을 <code>age</code> 필드에 할당할 때 <code>bipush</code> 명령어를 이용했었다는 것을 기억할 것입니다. 피연산자가 필요하지 않은 <code>iconst&#95;1</code> 명령어가 <code>bipush</code> 보다 효율적으로 동작하기 때문에 이곳에서는 <code>iconst&#95;1</code> 명령어가 사용되었습니다. <code>iconst&#95;&lt;i&gt;</code> 명령어는 총 7개로 -1에서 5까지의 값만 로드할 수 있기 때문에 앞선 코드에서는 <code>10</code>을 넣기 위해 <code>bipush</code>가 사용되었던 것입니다.</p><p>각 명령어에 대한 자세한 내용은 앞서 언급했던 <a href='http://en.wikipedia.org/wiki/Java_bytecode_instruction_listings'>위키피디아의 명령어 리스트</a>를 보면 쉽게 찾아볼 수 있습니다.</p><p>여기까지 바이트코드에 대한 기본적인 내용을 알아보았습니다. 이제 어떤 코드의 동작방식이 궁금하다면 명령어 리스트를 참고해가며 직접 바이트코드를 분석해 볼 수 있을 것입니다. 좀 더 깊은 내용을 알고 싶다면 <a href='http://docs.oracle.com/javase/specs/jvms/se7/html/index.html'>JVM 스팩</a>을 살펴보는 것을 추천해 드립니다.</p><h3>References</h3><ul><li><a href='http://en.wikipedia.org/wiki/Java_bytecode#Support_for_dynamic_languages'>Java bytecode From Wikipedia</a></li><li><a href='http://docs.oracle.com/javase/specs/jvms/se7/html/index.html'>The Java Virtual Machine Specification</a></li><li><a href='http://www.ibm.com/developerworks/ibm/library/it-haggar_bytecode/'>Java bytecode: Understanding bytecode makes you a better programmer</a></li><li><a href='http://arhipov.blogspot.kr/2011/01/java-bytecode-fundamentals.html'>Java Bytecode Fundamentals</a></li><li><a href='http://stackoverflow.com/questions/1642338/java-eclipse-how-does-eclipse-compile-classes-with-only-a-jre'>Java / Eclipse : How does Eclipse compile classes with only a JRE?</a> </i></comment></operand2></operand1></opcode></index></comment></operand2></operand1></opcode></index></li></ul>
</div>
    <section class="signup">
        <div class="container2">
            <!-- Begin MailChimp Signup Form -->
            <div id="mc_embed_signup">
                <form action="https://hjparenting.us17.list-manage.com/subscribe/post?u=8abdd78f471e341ecbf00840c&amp;id=423c9920d1" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
                    <div id="mc_embed_signup_scroll">

                        <div class="mc-field-group">
                            <input placeholder="이메일 주소" type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL"><input type="submit" value="블로그 구독" name="subscribe" id="mc-embedded-subscribe" class="subscribe button">
                        </div>
                        <div id="mce-responses" class="clear">
                            <div class="response" id="mce-error-response" style="display:none"></div>
                            <div class="response" id="mce-success-response" style="display:none"></div>
                        </div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
                        <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_8abdd78f471e341ecbf00840c_423c9920d1" tabindex="-1" value=""></div>
                    </div>
                </form>
            </div>
        </div>
    </section>
    <section class="icons">
        <div class="container">
            <div class="content">
                <a href="//github.com/sangdol" target="_blank" rel="noopener"><img class="icon" src="/img/github.svg" alt="github" /></a>
                <a href="//stackoverflow.com/users/524588/sanghyun-lee" target="_blank" rel="noopener"><img class="icon" src="/img/stackoverflow.svg" alt="stackoverflow" /></a>
                <a href="//twitter.com/sangdolha" target="_blank" rel="noopener"><img class="icon" src="/img/twitter.svg" alt="twitter" /></a>
                <a href="//linkedin.com/in/sanghyun-lee-b1129151" target="_blank" rel="noopener"><img class="icon" src="/img/linkedin.svg" alt="linkedin" /></a>
                <a href="mailto:hammerha+iamsang-kr@gmail.com"><img class="icon" src="/img/email.svg" alt="email" /></a>
                <a href="/index.xml"><img class="icon" src="/img/rss.svg" alt="rss" /></a>
            </div>
        </div>
    </section>
</body>
</html>
